<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog/1.9"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog/1.9
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd">


    <changeSet id="Create issue_status table" author="v.kostyukevich">
        <sql endDelimiter="#">
            CREATE TABLE `issue_status` (
            `id` INT(11) NOT NULL AUTO_INCREMENT,
            `color` INT(1) NOT NULL,
            `name` VARCHAR(50) NOT NULL,
            PRIMARY KEY (`id`),
            UNIQUE INDEX `id_UNIQUE` (`id` ASC),
            UNIQUE INDEX `name_UNIQUE` (`name` ASC));
            #
            INSERT INTO `issue_status` (`id`, `color`, `name`) VALUES ('1', '3', 'Open');
            #
            INSERT INTO `issue_status` (`id`, `color`, `name`) VALUES ('2', '4', 'Can Not Reproduce');
            #
            INSERT INTO `issue_status` (`id`, `color`, `name`) VALUES ('4', '5', 'Done');
            #
            INSERT INTO `issue_status` (`id`, `color`, `name`) VALUES ('5', '5', 'Closed');
            #
            INSERT INTO `issue_status` (`id`, `color`, `name`) VALUES ('3', '2', 'In Progress');

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Create issue_labels table" author="v.kostyukevich">
        <sql endDelimiter="#">
            CREATE TABLE `issue_labels` (
            `id` INT(11) NOT NULL AUTO_INCREMENT,
            `project_id` INT(11) NULL,
            `color` VARCHAR(45) NOT NULL DEFAULT '#f8f9fa',
            `name` VARCHAR(45) NOT NULL,
            PRIMARY KEY (`id`),
            UNIQUE INDEX `id_UNIQUE` (`id` ASC),
            INDEX `label_to_project_idx` (`project_id` ASC),
            CONSTRAINT `label_to_project`
            FOREIGN KEY (`project_id`)
            REFERENCES `projects` (`id`)
            ON DELETE CASCADE
            ON UPDATE CASCADE);
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Create issues table" author="v.kostyukevich">
        <sql endDelimiter="#">
            CREATE TABLE `issues` (
            `id` INT(11) NOT NULL AUTO_INCREMENT,
            `resolution_id` INT(11) NOT NULL DEFAULT '1',
            `title` VARCHAR(500) NOT NULL,
            `description` LONGTEXT NULL,
            `external_url` VARCHAR(500) NULL,
            `assignee_id` INT(11) NULL,
            `expression` VARCHAR(500) NULL,
            `status_id` INT(11) NOT NULL DEFAULT 1,
            `label_id` INT(11) NULL,
            `project_id` INT(11) NOT NULL,
            `creator_id` INT(11) NOT NULL,
            `created` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (`id`),
            INDEX `issue_to_resolution_idx` (`resolution_id` ASC),
            INDEX `issue_to_status_idx` (`status_id` ASC),
            INDEX `issue_to_label_idx` (`label_id` ASC),
            INDEX `issue_to_project_idx` (`project_id` ASC),
            INDEX `issue_to_user_idx` (`assignee_id` ASC),
            INDEX `issue_to_creator_idx` (`creator_id` ASC),
            CONSTRAINT `issue_to_resolution`
            FOREIGN KEY (`resolution_id`)
            REFERENCES `result_resolution` (`id`)
            ON DELETE RESTRICT
            ON UPDATE CASCADE,
            CONSTRAINT `issue_to_status`
            FOREIGN KEY (`status_id`)
            REFERENCES `issue_status` (`id`)
            ON DELETE RESTRICT
            ON UPDATE CASCADE,
            CONSTRAINT `issue_to_label`
            FOREIGN KEY (`label_id`)
            REFERENCES `issue_labels` (`id`)
            ON DELETE RESTRICT
            ON UPDATE CASCADE,
            CONSTRAINT `issue_to_project`
            FOREIGN KEY (`project_id`)
            REFERENCES `projects` (`id`)
            ON DELETE CASCADE
            ON UPDATE CASCADE,
            CONSTRAINT `issue_to_assignee`
            FOREIGN KEY (`assignee_id`)
            REFERENCES `users` (`id`)
            ON DELETE SET NULL
            ON UPDATE CASCADE,
            CONSTRAINT `issue_to_creator`
            FOREIGN KEY (`creator_id`)
            REFERENCES `users` (`id`)
            ON DELETE RESTRICT
            ON UPDATE CASCADE);

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Create INSERT_ISSUE" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP procedure IF EXISTS `INSERT_ISSUE`;

            #
            CREATE PROCEDURE `INSERT_ISSUE`(
            IN request_id VARCHAR(11),
            IN request_resolution_id VARCHAR(11),
            IN request_title VARCHAR(500),
            IN request_description LONGTEXT,
            IN request_external_url VARCHAR(500),
            IN request_assignee_id VARCHAR(11),
            IN request_expression VARCHAR(500),
            IN request_status_id VARCHAR(11),
            IN request_label_id VARCHAR(11),
            IN request_project_id VARCHAR(11),
            IN request_creator_id VARCHAR(11)
            )
            BEGIN
            INSERT INTO issues (id, resolution_id, title, description, external_url, assignee_id, expression, status_id, label_id, project_id, creator_id)
            VALUES (
            replace_empty(request_id, null),
            replace_empty(request_resolution_id, '1'),
            request_title,
            replace_empty(request_description, null),
            replace_empty(request_external_url, null),
            replace_empty(request_assignee_id, null),
            replace_empty(request_expression, null),
            replace_empty(request_status_id, '1'),
            replace_empty(request_label_id, null),
            request_project_id,
            request_creator_id
            ) ON DUPLICATE KEY UPDATE
            resolution_id = replace_empty(request_resolution_id, resolution_id),
            title = replace_empty(request_title, title),
            description = apply_or_remove_value(request_description, description),
            external_url = apply_or_remove_value(request_external_url, external_url),
            assignee_id = apply_or_remove_id(request_assignee_id, assignee_id),
            expression = apply_or_remove_value(request_expression, expression),
            status_id = replace_empty(request_status_id, status_id),
            label_id = apply_or_remove_id(request_label_id, label_id)
            ;

            SET @result_id = IF(request_id = '', LAST_INSERT_ID(), request_id);
            SELECT * from issues where id = @result_id;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Update test_results table with issues" author="v.kostyukevich">
        <sql endDelimiter="#">
            ALTER TABLE `test_results`
            ADD COLUMN `issue_id` INT(11) NULL AFTER `pending`,
            ADD INDEX `test_result_to_issue_idx` (`issue_id` ASC);
            #
            ALTER TABLE `test_results`
            ADD CONSTRAINT `test_result_to_issue`
            FOREIGN KEY (`issue_id`)
            REFERENCES `issues` (`id`)
            ON DELETE SET NULL
            ON UPDATE CASCADE;
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Update INSERT_TEST_RESULT with issues" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP procedure IF EXISTS `INSERT_TEST_RESULT`;

            #
            CREATE PROCEDURE `INSERT_TEST_RESULT`(
            IN request_project_id VARCHAR(10),
            IN request_id VARCHAR(10),
            IN request_test_id VARCHAR(500),
            IN request_final_result_id VARCHAR(500),
            IN request_comment text,
            IN request_test_run_id VARCHAR(500),
            IN request_test_resolution_id VARCHAR(10),
            IN request_log longtext,
            IN request_debug VARCHAR(1),
            IN request_finish_date VARCHAR(500),
            IN request_start_date VARCHAR(500),
            IN request_final_result_updated VARCHAR(500),
            IN request_fail_reason mediumtext,
            IN request_assignee VARCHAR(10),
            IN request_issue_id VARCHAR(11)
            )
            BEGIN
            INSERT INTO test_results (project_id, id, test_id, final_result_id, comment, test_run_id, test_resolution_id, log, debug, start_date, finish_date, final_result_updated, fail_reason, assignee, issue_id)
            VALUES (
            request_project_id,
            IF(request_id='', null, request_id),
            request_test_id,
            IF(request_final_result_id='',1,request_final_result_id),
            IF(request_comment = '', null, request_comment),
            IF(request_test_run_id = '', null, request_test_run_id),
            IF(request_test_resolution_id = '', 1, request_test_resolution_id),
            IF(request_log = '', null, request_log),
            IF(request_debug = '', 0, request_debug),
            If(request_start_date = '', null, FROM_UNIXTIME(request_start_date)),
            If(request_finish_date = '', null, FROM_UNIXTIME(request_finish_date)),
            NOW(),
            IF(request_fail_reason = '', null, request_fail_reason),
            IF(request_assignee = '', null, request_assignee),
            replace_empty(request_issue_id, null))
            ON DUPLICATE KEY UPDATE
            test_id=IF(request_test_id = '',test_id,request_test_id),
            final_result_id = IF(request_final_result_id = '', final_result_id, request_final_result_id),
            comment = IF(request_comment = '', IF(comment = null OR '', null, comment), IF(request_comment='$blank', null, request_comment)),
            test_resolution_id = IF(final_result_id = 2, 1, IF(request_test_resolution_id='', test_resolution_id, request_test_resolution_id)),
            log = IF(request_log = '', log, IF(request_log = '$blank', '', request_log)),
            debug = IF(request_debug = '', debug, request_debug),
            start_date = If(request_start_date = '', start_date, FROM_UNIXTIME(request_start_date)),
            finish_date = If(request_finish_date = '', finish_date, FROM_UNIXTIME(request_finish_date)),
            final_result_updated = IF(request_final_result_id = final_result_id AND request_final_result_updated = '', NOW(), IF(request_final_result_updated = '',final_result_updated, FROM_UNIXTIME(request_final_result_updated))),
            fail_reason = IF(request_fail_reason = '', fail_reason, IF(request_fail_reason = '$blank', '', request_fail_reason)),
            assignee = IF(request_assignee = '', null, request_assignee),
            issue_id = apply_or_remove_id(request_issue_id, issue_id)
            ;
            SET @insert_id = IF(request_id = '', (SELECT LAST_INSERT_ID()), request_id);
            SELECT * from test_results where id = @insert_id;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create migrate_results_to_issues" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP procedure IF EXISTS `migrate_results_to_issues`;

            #
            CREATE PROCEDURE `migrate_results_to_issues`()
            BEGIN

            DECLARE my_id int;
            DECLARE my_test_id int;
            DECLARE my_final_result_id int;
            DECLARE my_test_resolution_id int;
            DECLARE my_assignee int;
            DECLARE my_project_id int;
            DECLARE my_comment mediumtext;
            DECLARE my_current_issue int;
            DECLARE done TINYINT DEFAULT FALSE;

            DECLARE result_cursor
            CURSOR FOR
            SELECT id, test_id, final_result_id, test_resolution_id, assignee, project_id, comment
            FROM test_results WHERE final_result_id != 2 AND (test_resolution_id != 1 OR comment is not null);

            DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

            OPEN result_cursor;

            results_loop: LOOP

            FETCH NEXT FROM result_cursor INTO my_id, my_test_id, my_final_result_id, my_test_resolution_id, my_assignee, my_project_id, my_comment;
            IF done THEN
            LEAVE results_loop;
            ELSE

            IF(my_comment IS NOT null) THEN
            IF EXISTS (SELECT * FROM issues WHERE project_id=my_project_id AND title=IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment)) THEN
            SELECT id INTO @my_current_issue FROM issues WHERE project_id=my_project_id AND title=IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment);

            call INSERT_ISSUE(@my_current_issue, my_test_resolution_id,
            IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment),
            IF(CHAR_LENGTH(my_comment) > 500, my_comment, null), '', my_assignee, '', '', '', my_project_id, '1');

            call INSERT_TEST_RESULT(my_project_id, my_id, my_test_id,'','','','','','','','','','','', @my_current_issue);
            ELSE
            call INSERT_ISSUE('', my_test_resolution_id,
            IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment),
            IF(CHAR_LENGTH(my_comment) > 500, my_comment, null), '', my_assignee, '', '', '', my_project_id, '1');

            SELECT id INTO @my_current_issue FROM issues WHERE project_id=my_project_id
            AND title=IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment);
            call INSERT_TEST_RESULT(my_project_id, my_id, my_test_id,'','','','','','','','','','','', @my_current_issue);
            END IF;

            ELSE
            IF EXISTS (SELECT * FROM issues WHERE project_id=my_project_id AND title=CAST(my_test_resolution_id as unsigned)) THEN
            SELECT id INTO @my_current_issue FROM issues WHERE project_id=my_project_id AND title=CAST(my_test_resolution_id as unsigned);

            call INSERT_ISSUE(@my_current_issue, my_test_resolution_id, my_test_resolution_id, '', '', my_assignee, '', '', '', my_project_id, '1');

            call INSERT_TEST_RESULT(my_project_id, my_id, my_test_id,'','','','','','','','','','','', @my_current_issue);
            ELSE
            call INSERT_ISSUE('', my_test_resolution_id, my_test_resolution_id, '', '', my_assignee, '', '', '', my_project_id, '1');

            SELECT id INTO @my_current_issue FROM issues WHERE project_id=my_project_id AND title=my_test_resolution_id;
            call INSERT_TEST_RESULT(my_project_id, my_id, my_test_id,'','','','','','','','','','','', @my_current_issue);
            END IF;
            END IF;

            END IF;
            END LOOP;

            CLOSE result_cursor;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update replace_empty with longtext and utf8" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP FUNCTION IF EXISTS `replace_empty`;

            #
            CREATE FUNCTION `replace_empty`(
            request_value longtext,
            current_value longtext
            ) RETURNS longtext CHARSET utf8
            BEGIN
            RETURN IF (request_value='', current_value, request_value);
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Execute results migration" author="v.kostyukevich">
        <sql endDelimiter="#">
            call migrate_results_to_issues();
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create migrate_predefined_resolutions_to_issues" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP procedure IF EXISTS `migrate_predefined_resolutions_to_issues`;

            #
            CREATE PROCEDURE `migrate_predefined_resolutions_to_issues`()
            BEGIN

            DECLARE my_id int;
            DECLARE my_project_id int;
            DECLARE my_resolution_id int;
            DECLARE my_comment mediumtext;
            DECLARE my_assignee int;
            DECLARE my_expression VARCHAR(500);
            DECLARE my_current_issue int;
            DECLARE done TINYINT DEFAULT FALSE;

            DECLARE predefined_resolutions_cursor
            CURSOR FOR
            SELECT id, project_id, resolution_id, comment, assignee, expression
            FROM predefined_resolutions where comment is not null;

            DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

            OPEN predefined_resolutions_cursor;

            predefined_resolutions_loop: LOOP

            FETCH NEXT FROM predefined_resolutions_cursor INTO my_id, my_project_id, my_resolution_id, my_comment, my_assignee, my_expression;
            IF done THEN
            LEAVE predefined_resolutions_loop;
            ELSE

            IF EXISTS (SELECT * FROM issues WHERE project_id=my_project_id AND title=IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment)) THEN
            SELECT id INTO @my_current_issue FROM issues WHERE project_id=my_project_id AND title=IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment);

            call INSERT_ISSUE(@my_current_issue, my_resolution_id,
            IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment),
            IF(CHAR_LENGTH(my_comment) > 500, my_comment, null), '', my_assignee, my_expression, '', '', my_project_id, '1');

            ELSE
            call INSERT_ISSUE('', my_resolution_id,
            IF(CHAR_LENGTH(my_comment) > 500, CONCAT(LEFT(my_comment, 497),"..."), my_comment),
            IF(CHAR_LENGTH(my_comment) > 500, my_comment, null), '', my_assignee, my_expression, '', '', my_project_id, '1');
            END IF;
            END IF;
            END LOOP;

            CLOSE predefined_resolutions_cursor;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Execute predefined_resolutions migration" author="v.kostyukevich">
        <sql endDelimiter="#">
            call migrate_predefined_resolutions_to_issues();
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="Remove temp procedures" author="v.kostyukevich">
        <sql endDelimiter="#">
            DROP procedure IF EXISTS `migrate_predefined_resolutions_to_issues`;
            #
            DROP procedure IF EXISTS `migrate_results_to_issues`;
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create get_valid_limit" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP FUNCTION IF EXISTS `get_valid_limit`;

            #
            CREATE FUNCTION `get_valid_limit`(
            request_value VARCHAR(11)
            ) RETURNS int(11)
            BEGIN
            RETURN IF(request_value='', 10000, request_value);
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create SELECT_ISSUES" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_ISSUES`;

            #
            CREATE PROCEDURE `SELECT_ISSUES`(
            IN request_project_id VARCHAR(11),
            IN request_id VARCHAR(11),
            IN request_assignee_id VARCHAR(11),
            IN request_status_id VARCHAR(11),
            IN request_label_id VARCHAR(11),
            IN request_resolution_id VARCHAR(11),
            In request_limit VARCHAR(11)
            )
            BEGIN
            declare valid_limit int;
            SET valid_limit = get_valid_limit(request_limit);
            SELECT * FROM issues
            WHERE empty_or_equal(request_project_id,project_id)
            AND empty_or_equal(request_id, id)
            AND empty_or_equal(request_assignee_id, assignee_id)
            AND empty_or_equal(request_status_id, status_id)
            AND empty_or_equal(request_label_id, label_id)
            AND empty_or_equal(request_resolution_id, resolution_id)
            ORDER BY created DESC
            LIMIT valid_limit
            ;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update SELECT_TEST_RESULT with issue_id" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_TEST_RESULT`;

            #
            CREATE PROCEDURE `SELECT_TEST_RESULT`(
            IN request_project_id VARCHAR(10),
            IN request_id VARCHAR(10),
            IN request_test_id VARCHAR(10),
            IN request_final_result_id VARCHAR(10),
            IN request_test_run_id VARCHAR(10),
            IN request_test_resolution_id VARCHAR(10),
            IN request_debug VARCHAR(1),
            IN request_fail_reason VARCHAR(150),
            IN request_fail_reason_regex VARCHAR(500),
            IN request_issue_id VARCHAR(11),
            In request_limit VARCHAR(11)
            )
            BEGIN
            declare valid_limit int;
            SET valid_limit = get_valid_limit(request_limit);

            IF(request_fail_reason_regex = '') THEN SET request_fail_reason_regex = '.*';
            END IF;

            SELECT * FROM test_results as res
            WHERE (request_id='' OR request_id=id)
            AND (request_project_id='' OR request_project_id=project_id)
            AND (request_test_id='' OR request_test_id=test_id)
            AND (request_final_result_id='' OR request_final_result_id=final_result_id)
            AND (request_test_run_id='' OR request_test_run_id=test_run_id)
            AND (request_test_resolution_id='' OR request_test_resolution_id=test_resolution_id)
            AND (request_debug='' OR request_debug=debug)
            AND (request_fail_reason='' OR INSTR(fail_reason, request_fail_reason) > 0)
            AND IFNULL(fail_reason, '') REGEXP request_fail_reason_regex
            AND (request_issue_id='' OR request_issue_id=issue_id)
            ORDER BY start_date DESC
            LIMIT valid_limit
            ;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create SELECT_ISSUE_STATUS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_ISSUE_STATUS`;

            #
            CREATE PROCEDURE `SELECT_ISSUE_STATUS` (
            In request_id varchar(11)
            )
            BEGIN
            SELECT * FROM issue_status WHERE empty_or_equal(request_id,id);
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create issues_BEFORE_INSERT" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `issues_BEFORE_INSERT`;

            #
            CREATE TRIGGER `issues_BEFORE_INSERT` BEFORE INSERT ON `issues` FOR EACH ROW
            BEGIN
            IF EXISTS (SELECT * FROM issues WHERE title = NEW.title AND project_id = NEW.project_id AND id != NEW.id)
            THEN SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot create! Issue with this title already exists in this Project!';
            END IF;

            IF EXISTS (SELECT * FROM issues WHERE expression = NEW.expression AND project_id = NEW.project_id AND id != NEW.id)
            THEN SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot create! Issue with this expression already exists in this Project!';
            END IF;
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create issues_BEFORE_UPDATE" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `issues_BEFORE_UPDATE`;

            #
            CREATE TRIGGER `issues_BEFORE_UPDATE` BEFORE UPDATE ON `issues` FOR EACH ROW
            BEGIN
            IF EXISTS (SELECT * FROM issues WHERE title = NEW.title AND project_id = NEW.project_id AND id != NEW.id)
            THEN SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot Update! Issue with this title already exists in this Project!';
            END IF;

            IF EXISTS (SELECT * FROM issues WHERE expression = NEW.expression AND project_id = NEW.project_id AND id != NEW.id)
            THEN SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Cannot Update! Issue with this expression already exists in this Project!';
            END IF;
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update SELECT_TEST_RUN with limit function" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_TEST_RUN`;

            #
            CREATE PROCEDURE `SELECT_TEST_RUN`(
            IN request_id VARCHAR(10),
            IN request_build_name VARCHAR(500),
            IN request_milestone_id VARCHAR(10),
            IN request_test_suite_id VARCHAR(10),
            IN request_project_id VARCHAR(10),
            IN request_execution_environment VARCHAR(500),
            IN request_debug VARCHAR(1),
            IN request_label_id VARCHAR(11),
            IN request_limit VARCHAR(11)
            )
            BEGIN
            declare valid_limit int;
            SET valid_limit = get_valid_limit(request_limit);

            SELECT
            runs.*,
            mil.name as milestone_name,
            suite.name as testsuite_name

            FROM union_reporting.test_runs as runs
            LEFT JOIN union_reporting.milestones as mil ON runs.milestone_id = mil.id
            LEFT JOIN union_reporting.test_suites as suite ON runs.test_suite_id = suite.id

            WHERE (request_id= '' OR runs.id=request_id)
            AND (request_build_name = '' OR build_name=request_build_name)
            AND (request_milestone_id = '' OR milestone_id=request_milestone_id OR IF(request_milestone_id=0, milestone_id IS NULL, request_milestone_id = ''))
            AND (request_test_suite_id = '' OR test_suite_id=request_test_suite_id)
            AND (request_project_id = '' OR runs.project_id=request_project_id)
            AND (request_execution_environment = '' OR execution_environment=request_execution_environment)
            AND (request_debug = '' OR runs.debug=request_debug)
            AND (request_label_id = '' OR runs.label_id=request_label_id)
            ORDER BY finish_time DESC
            LIMIT valid_limit
            ;
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `UPDATE_TEST_RUN_STATS`;

            #
            CREATE PROCEDURE `UPDATE_TEST_RUN_STATS`(
            In request_testrun_id varchar(11)
            )
            BEGIN
            DELETE FROM testrun_statistic WHERE testrun_id = request_testrun_id;

            INSERT INTO testrun_statistic (testrun_id, failed, passed, not_executed, in_progress, pending, total, app_issue, warning, not_assigned, other)

            SELECT
            trn.id,
            sum(frs.color = 1) as failed,
            sum(frs.color = 5) as passed,
            sum(frs.color = 3) as not_executed,
            sum(frs.color = 2) as in_progress,
            sum(frs.color = 4) as pending,
            sum(frs.color != 0) as total,
            sum(rr.color = 1 AND frs.color != 5) as app_issue,
            sum(rr.color = 2 AND frs.color != 5) as warning,
            sum((rr.color = 3 or rr.color is null) AND frs.color != 5) as not_assigned,
            sum((rr.color = 4 OR rr.color = 5) AND frs.color != 5) as other

            from test_runs as trn
            right join test_results as trs on trn.id=test_run_id
            left join final_results as frs on trs.final_result_id = frs.id
            left join issues on trs.issue_id=issues.id
            left join result_resolution as rr on issues.resolution_id = rr.id

            Where trn.id = request_testrun_id;
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results_AFTER_INSERT with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `test_results_AFTER_INSERT`;

            #
            CREATE TRIGGER test_results_AFTER_INSERT AFTER INSERT ON test_results FOR EACH ROW
            BEGIN

            IF NOT EXISTS (SELECT * FROM imports WHERE testrun_id= NEW.test_run_id AND finish_status = 0)
            THEN

            CALL UPDATE_TEST_RUN_STATS(NEW.test_run_id);

            END IF;

            CALL UPDATE_LAST_RESULT_COLORS_FOR_TEST (
            NEW.test_id,
            (SELECT stability_count from projects where id = NEW.project_id));
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results_AFTER_INSERT with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `test_results_AFTER_INSERT`;

            #
            CREATE TRIGGER test_results_AFTER_INSERT AFTER INSERT ON test_results FOR EACH ROW
            BEGIN

            IF NOT EXISTS (SELECT * FROM imports WHERE testrun_id= NEW.test_run_id AND finish_status = 0)
            THEN

            CALL UPDATE_TEST_RUN_STATS(NEW.test_run_id);

            END IF;

            CALL UPDATE_LAST_RESULT_COLORS_FOR_TEST (
            NEW.test_id,
            (SELECT stability_count from projects where id = NEW.project_id));
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results_AFTER_UPDATE with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `test_results_AFTER_UPDATE`;

            #
            CREATE TRIGGER test_results_AFTER_UPDATE AFTER UPDATE ON test_results FOR EACH ROW
            BEGIN
            IF NOT EXISTS (SELECT * FROM imports WHERE testrun_id= NEW.test_run_id AND finish_status = 0)
            THEN

            CALL UPDATE_TEST_RUN_STATS(NEW.test_run_id);

            END IF;

            CALL UPDATE_LAST_RESULT_COLORS_FOR_TEST (
            NEW.test_id,
            (SELECT stability_count from projects where id = NEW.project_id)
            );
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results_BEFORE_DELETE with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `test_results_BEFORE_DELETE`;

            #
            CREATE TRIGGER `test_results_BEFORE_DELETE` BEFORE DELETE ON `test_results` FOR EACH ROW
            BEGIN
            IF NOT EXISTS (SELECT * FROM imports WHERE testrun_id= OLD.test_run_id AND finish_status = 0)
            THEN

            CALL UPDATE_TEST_RUN_STATS(OLD.test_run_id);

            END IF;

            CALL UPDATE_LAST_RESULT_COLORS_FOR_TEST (
            OLD.test_id,
            (SELECT stability_count from projects where id = OLD.project_id)
            );
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results_AFTER_DELETE with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `test_results_AFTER_DELETE`;

            #
            CREATE TRIGGER test_results_AFTER_DELETE AFTER DELETE ON test_results FOR EACH ROW
            BEGIN
            IF NOT EXISTS (SELECT * FROM imports WHERE testrun_id= OLD.test_run_id AND finish_status = 0)
            THEN

            CALL UPDATE_TEST_RUN_STATS(OLD.test_run_id);

            END IF;

            CALL UPDATE_LAST_RESULT_COLORS_FOR_TEST (OLD.test_id, (SELECT stability_count from projects where id = OLD.project_id));
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update UPDATE_LAST_RESULT_COLORS_FOR_TEST with Issues" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `UPDATE_LAST_RESULT_COLORS_FOR_TEST`;

            #
            CREATE PROCEDURE `UPDATE_LAST_RESULT_COLORS_FOR_TEST`(
            IN request_test_id INT(10),
            IN request_limit INT(10)
            )
            BEGIN
            DELETE FROM last_test_results WHERE test_id = request_test_id;

            INSERT INTO last_test_results (test_id, resolution_colors, result_colors, result_ids)

            select
            request_test_id,
            GROUP_CONCAT(resolutions SEPARATOR ',') as resolution_colors,
            GROUP_CONCAT(results SEPARATOR ',') as result_colors,
            GROUP_CONCAT(result_id SEPARATOR ',') as result_ids
            FROM (
            select request_test_id, CASE WHEN result_resolution.color is NULL THEN 3 ELSE result_resolution.color END as resolutions, final_results.color as results, test_results.id as result_id
            from test_results
            left join issues on issue_id=issues.id
            left join result_resolution on issues.resolution_id = result_resolution.id
            left join final_results on final_result_id = final_results.id

            where test_id = request_test_id AND test_results.debug = 0
            order by finish_date DESC
            limit request_limit) as results;
            END

        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update imports_AFTER_INSERT with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `imports_AFTER_INSERT`;

            #
            CREATE TRIGGER imports_AFTER_INSERT AFTER INSERT ON imports FOR EACH ROW
            BEGIN
            IF (NEW.finish_status = 1 AND new.testrun_id IS NOT NULL)
            THEN

            CALL UPDATE_TEST_RUN_STATS(NEW.testrun_id);

            END IF;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update imports_AFTER_UPDATE with UPDATE_TEST_RUN_STATS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP TRIGGER IF EXISTS `imports_AFTER_UPDATE`;

            #
            CREATE TRIGGER imports_AFTER_UPDATE AFTER UPDATE ON imports FOR EACH ROW
            BEGIN
            IF (NEW.finish_status = 1 AND new.testrun_id IS NOT NULL)
            THEN

            CALL UPDATE_TEST_RUN_STATS(NEW.testrun_id);

            END IF;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="create SELECT_ISSUE_TESTS" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_ISSUE_TESTS`;

            #
            CREATE PROCEDURE `SELECT_ISSUE_TESTS`(
            IN request_issue_id VARCHAR(10)
            )
            BEGIN
            SELECT DISTINCT tests.*, last_test_results.* FROM test_results
            LEFT JOIN tests ON test_results.test_id = tests.id
            LEFT JOIN last_test_results on tests.id = last_test_results.test_id
            WHERE issue_id = request_issue_id;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update INSERT_TEST_RESULT remove resolution, comment and assignee" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `INSERT_TEST_RESULT`;

            #
            CREATE PROCEDURE `INSERT_TEST_RESULT`(
            IN request_project_id VARCHAR(10),
            IN request_id VARCHAR(10),
            IN request_test_id VARCHAR(500),
            IN request_final_result_id VARCHAR(500),
            IN request_test_run_id VARCHAR(500),
            IN request_log longtext,
            IN request_debug VARCHAR(1),
            IN request_finish_date VARCHAR(500),
            IN request_start_date VARCHAR(500),
            IN request_final_result_updated VARCHAR(500),
            IN request_fail_reason mediumtext,
            IN request_issue_id VARCHAR(11)
            )
            BEGIN
            INSERT INTO test_results (project_id, id, test_id, final_result_id, test_run_id, log, debug, start_date, finish_date, final_result_updated, fail_reason, issue_id)
            VALUES (
            request_project_id,
            IF(request_id='', null, request_id),
            request_test_id,
            IF(request_final_result_id='',1,request_final_result_id),
            IF(request_test_run_id = '', null, request_test_run_id),
            IF(request_log = '', null, request_log),
            IF(request_debug = '', 0, request_debug),
            If(request_start_date = '', null, FROM_UNIXTIME(request_start_date)),
            If(request_finish_date = '', null, FROM_UNIXTIME(request_finish_date)),
            NOW(),
            IF(request_fail_reason = '', null, request_fail_reason),
            replace_empty(request_issue_id, null))
            ON DUPLICATE KEY UPDATE
            test_id=IF(request_test_id = '',test_id,request_test_id),
            final_result_id = IF(request_final_result_id = '', final_result_id, request_final_result_id),
            log = IF(request_log = '', log, IF(request_log = '$blank', '', request_log)),
            debug = IF(request_debug = '', debug, request_debug),
            start_date = If(request_start_date = '', start_date, FROM_UNIXTIME(request_start_date)),
            finish_date = If(request_finish_date = '', finish_date, FROM_UNIXTIME(request_finish_date)),
            final_result_updated = IF(request_final_result_id = final_result_id AND request_final_result_updated = '', NOW(), IF(request_final_result_updated = '',final_result_updated, FROM_UNIXTIME(request_final_result_updated))),
            fail_reason = IF(request_fail_reason = '', fail_reason, IF(request_fail_reason = '$blank', '', request_fail_reason)),
            issue_id = apply_or_remove_id(request_issue_id, issue_id)
            ;
            SET @insert_id = IF(request_id = '', (SELECT LAST_INSERT_ID()), request_id);
            SELECT * from test_results where id = @insert_id;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update SELECT_TEST_RESULT remove resolution" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `SELECT_TEST_RESULT`;

            #
            CREATE PROCEDURE `SELECT_TEST_RESULT`(
            IN request_project_id VARCHAR(10),
            IN request_id VARCHAR(10),
            IN request_test_id VARCHAR(10),
            IN request_final_result_id VARCHAR(10),
            IN request_test_run_id VARCHAR(10),
            IN request_debug VARCHAR(1),
            IN request_fail_reason VARCHAR(150),
            IN request_fail_reason_regex VARCHAR(500),
            IN request_issue_id VARCHAR(11),
            In request_limit VARCHAR(11)
            )
            BEGIN
            declare valid_limit int;
            SET valid_limit = get_valid_limit(request_limit);

            IF(request_fail_reason_regex = '') THEN SET request_fail_reason_regex = '.*';
            END IF;

            SELECT * FROM test_results as res
            WHERE (request_id='' OR request_id=id)
            AND (request_project_id='' OR request_project_id=project_id)
            AND (request_test_id='' OR request_test_id=test_id)
            AND (request_final_result_id='' OR request_final_result_id=final_result_id)
            AND (request_test_run_id='' OR request_test_run_id=test_run_id)
            AND (request_debug='' OR request_debug=debug)
            AND (request_fail_reason='' OR INSTR(fail_reason, request_fail_reason) > 0)
            AND IFNULL(fail_reason, '') REGEXP request_fail_reason_regex
            AND (request_issue_id='' OR request_issue_id=issue_id)
            ORDER BY start_date DESC
            LIMIT valid_limit
            ;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update test_results table remove resolution, comment and assignee" author="v.kostyukevich">
        <sql endDelimiter="#">

            ALTER TABLE `test_results`
            DROP FOREIGN KEY `test_result_test_resolution`,
            DROP FOREIGN KEY `test_result_assignee`;
            #
            ALTER TABLE `test_results`
            DROP COLUMN `assignee`,
            DROP COLUMN `test_resolution_id`,
            DROP COLUMN `comment`,
            DROP INDEX `test_result_test_resolution_idx` ,
            DROP INDEX `test_result_assignee_idx` ;
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update result_resolution table with resolution_to_project CONSTRAINT" author="v.kostyukevich">
        <sql endDelimiter="#">

            ALTER TABLE `result_resolution`
            ADD INDEX `resolution_to_project_idx` (`project_id` ASC);
            #

            ALTER TABLE `result_resolution`
            ADD CONSTRAINT `resolution_to_project`
            FOREIGN KEY (`project_id`)
            REFERENCES `union_reporting`.`projects` (`id`)
            ON DELETE CASCADE
            ON UPDATE CASCADE;
        </sql>
        <rollback>
        </rollback>
    </changeSet>

    <changeSet id="update REMOVE_RESULT_RESOLUTION remove resolution" author="v.kostyukevich">
        <sql endDelimiter="#">

            DROP PROCEDURE IF EXISTS `REMOVE_RESULT_RESOLUTION`;

            #
            CREATE PROCEDURE `REMOVE_RESULT_RESOLUTION`(
            IN request_id VARCHAR(11)
            )
            BEGIN
            DELETE FROM result_resolution
            WHERE id=request_id;
            END
        </sql>
        <rollback>
        </rollback>
    </changeSet>

</databaseChangeLog>
